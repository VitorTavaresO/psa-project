\documentclass[12pt]{article}

\usepackage{sbc-template}
\usepackage{graphicx,url}
\usepackage[brazil]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[dvipsnames]{xcolor}

\lstset{
    language=Python,
    basicstyle=\ttfamily,
    keywordstyle=\bfseries\color{Fuchsia},
    commentstyle=\bfseries\itshape\color{gray},
    stringstyle=\bfseries\color{ForestGreen},
    identifierstyle=\bfseries\color{black},
    emphstyle=\color{Violet},
    frame=single,
    breaklines=true,
    numbers=left,
    numbersep=5pt,
    xleftmargin=10pt,
    xrightmargin=10pt,
    showstringspaces=false,
    morekeywords={int, str, float},
}

\sloppy

\title{Os Riscos da Dependência Cega de IA para o Desenvolvimento de Software}

\author{Aline Yuka Noguti \inst{1}, Eduardo Albuquerque\inst{1}, Vitor Tavares\inst{1}}

\address{Instituto Federal do Paraná - Campus Paranavaí - IFPR}

\begin{document}

\maketitle

\section{Introdução}

A Inteligência Artificial tem revolucionado diversas áreas da tecnologia, e o desenvolvimento de software não é exceção, com a popularização de assistentes de programação, como ChatGPT e Copilot, desenvolvedores podem gerar código rapidamente, otimizar tarefas repetitivas e solucionar problemas com mais eficiência. No entanto, essa facilidade levanta um debate importante: até que ponto a IA no desenvolvimento de software pode ser benéfica, e quando ela se torna um problema?

Este trabalho explora os riscos da utilização indiscriminada da IA como ferramenta principal no desenvolvimento de software, especialmente quando usada por indivíduos sem conhecimento técnico suficiente para validar as soluções propostas, por meio de um estudo de caso prático, analisaremos o desenvolvimento de um scanner de IP para identificar portas abertas e protocolos de rede, feito por um usuário sem experiência prévia na área de redes.

A criação de um sistema sem um planejamento adequado, validação técnica e compreensão sólida de seus fundamentos pode resultar em código ineficiente, inseguro e difícil de manter e à medida que o projeto se torna mais complexo, esses problemas tendem a se agravar, comprometendo não apenas seu desempenho, mas também sua confiabilidade e escalabilidade.

Com isso pretende-se demonstrar como a aceitação cega de códigos gerados por IA pode resultar em problemas que o próprio programador não consegue solucionar, criando um ciclo vicioso de dependência, a pesquisa destaca tanto os benefícios da IA no desenvolvimento de software quanto os riscos associados ao seu uso inconsequente, evidenciando a importância do conhecimento técnico para interpretar, validar e corrigir o código gerado.

\section{Metodologia da Análise}

A análise foi conduzida com o objetivo de identificar os impactos da dependência da Inteligência Artificial (IA) no desenvolvimento de software, avaliando tanto os benefícios quanto os desafios enfrentados por um usuário sem conhecimento prévio da área de redes ao construir um scanner de IP com auxílio da IA.

\subsection{Monitoramento das Interações}

Um dos membros da equipe foi responsável por acompanhar o participante que utilizou a IA para desenvolver o sistema. Durante o desenvolvimento, foram registradas todas as interações realizadas com a IA, incluindo:
\\
\\

\begin{itemize}
    \item As perguntas feitas pelo participante.
    \item Os códigos gerados pela IA.
    \item As edições aplicadas pelo participante nos códigos gerados.
    \item As dificuldades enfrentadas durante o processo.
\end{itemize}

O processo de tomada de decisão do participante foi analisado, observando quando e como ele aceitava, modificava ou rejeitava as respostas fornecidas pela IA. Interações problemáticas foram documentadas, destacando casos onde o código gerado pela IA apresentou:

\begin{itemize}
    \item Erros de funcionamento.
    \item Falhas de segurança.
    \item Inconsistências no código.
    \item Dificuldades de implementação.
\end{itemize}

\subsection{Registro de Resultados e Problemas Identificados}

As principais dificuldades encontradas pelo participante foram registradas, incluindo:

\begin{itemize}
    \item Erros de funcionamento do código gerado.
    \item Falhas na interpretação do código fornecido pela IA.
    \item Necessidade de múltiplas interações para resolver um único problema.
\end{itemize}

Foi avaliada a capacidade do participante de compreender e corrigir os erros por conta própria ou se ele precisou recorrer novamente à IA, criando um ciclo de dependência.

\subsection{Análise Externa e Conclusões}

Após o período de desenvolvimento e monitoramento, um terceiro membro da equipe, que não participou diretamente da criação do código nem do acompanhamento, realizou uma análise crítica aprofundada. Esse membro avaliou os dados coletados, buscando:

\begin{itemize}
    \item Padrões de dependência da IA.
    \item Impactos na qualidade do código gerado.
    \item Desafios enfrentados pelo participante durante o desenvolvimento.
\end{itemize}

A análise buscou extrair insights sobre os benefícios proporcionados pela IA, mirando em aspectos específicos como por exemplo:

\begin{itemize}
    \item Agilidade no desenvolvimento.
    \item Auxílio na solução de problemas.
\end{itemize}

E a análise buscou identificar possíveis problemas da utilização da ferramenta de forma indiscriminada pelo desenvolvedor, focando principalmente nos seguintes aspectos:

\begin{itemize}
    \item Falta de compreensão do código gerado.
    \item Riscos de segurança e manutenção associados ao uso da IA.
\end{itemize}

A análise final relacionou esses aspectos com conceitos da disciplina de Projeto Avançado de Software, destacando a importância de um desenvolvimento estruturado e da validação técnica no uso de IA. Essa abordagem permitiu uma avaliação detalhada dos efeitos da dependência da IA no desenvolvimento de software, oferecendo uma visão equilibrada entre seus benefícios e os riscos associados ao seu uso sem conhecimento técnico adequado.


\section{Prompts e Respostas}

\subsection{\textbf{Prompt:}  "Criar um script básico em Python para aceitar um endereço IP ou domínio como entrada". }
    \begin{lstlisting}
    def main():
    target = input("Digite o endereco IP ou dominio para escanear: ")
    if not target.strip():
        print("Erro: Nenhum endereco IP ou dominio foi fornecido.")
        return
    print(f"Alvo recebido: {target}")

if __name__ == "__main__":
    main()
    \end{lstlisting}
\subsection{\textbf{Prompt:} "O que significa e para que serve o .strip()"}
    \textbf{Resposta:} O método .strip() em Python é usado para remover espaços em branco (ou outros caracteres especificados) do início e do fim de uma string.

\subsection{\textbf{Prompt:} "Trabalhar apenas com IP"}
    \begin{lstlisting}
    import ipaddress

def main():
    target = input("Digite o endereco IP para escanear: ")
    if not target.strip():
        print("Erro: Nenhum endereco IP foi fornecido.")
        return
    try:
        ipaddress.ip_address(target)
        print(f"Alvo recebido: {target}")
    except ValueError:
        print("Erro: O endereco fornecido nao e um IP valido.")

if __name__ == "__main__":
    main()
    \end{lstlisting}
\subsection{\textbf{Prompt:} "Como integrar isso: 'Usar socket para verificar quais portas estão abertas. Integrar a biblioteca nmap para identificar os serviços ativos."}

    \begin{lstlisting}
    import ipaddress
import socket
import nmap

def scan_ports_with_socket(target):
    print("\n[+] Escaneando portas abertas com socket...")
    open_ports = []
    for port in range(1, 1025):  # Escaneia as portas de 1 a 1024
        try:
            with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
                s.settimeout(0.5)  # Define um timeout para evitar travamentos
                if s.connect_ex((target, port)) == 0:
                    open_ports.append(port)
                    print(f"[+] Porta {port} aberta")
        except Exception as e:
            print(f"Erro ao escanear a porta {port}: {e}")
    return open_ports

def scan_services_with_nmap(target):
    print("\n[+] Identificando servicos ativos com nmap...")
    nm = nmap.PortScanner()
    try:
        nm.scan(hosts=target, arguments='-sV')  # Escaneia servicos com deteccao de versao
        for host in nm.all_hosts():
            print(f"\nHost: {host} ({nm[host].hostname()})")
            print(f"Estado: {nm[host].state()}")
            for proto in nm[host].all_protocols():
                print(f"\nProtocolo: {proto}")
                ports = nm[host][proto].keys()
                for port in ports:
                    service = nm[host][proto][port]
                    print(f"Porta: {port}\tEstado: {service['state']}\tServico: {service['name']}")
    except Exception as e:
        print(f"Erro ao usar nmap: {e}")

def main():
    # Solicita ao usuario um endereco IP
    target = input("Digite o endereco IP para escanear: ")

    # Valida se o usuario forneceu uma entrada
    if not target.strip():
        print("Erro: Nenhum endereco IP foi fornecido.")
        return

    # Valida se o endereco fornecido e um IP valido
    try:
        ipaddress.ip_address(target)
        print(f"Alvo recebido: {target}")

        # Escaneia portas abertas com socket
        open_ports = scan_ports_with_socket(target)

        # Identifica servicos ativos com nmap
        if open_ports:
            scan_services_with_nmap(target)
        else:
            print("Nenhuma porta aberta encontrada para escanear servicos.")
    except ValueError:
        print("Erro: O endereco fornecido nao e um IP valido.")

if _name_ == "_main_":
    main()
    \end{lstlisting}

\subsection{\textbf{Prompt:}"O que seria a biblioteca Socket?"}
    \textbf{Resposta:} Boa pergunta! A biblioteca socket em Python é um módulo que permite a comunicação entre computadores em uma rede — seja local (LAN) ou pela internet — usando os protocolos TCP/IP ou UDP.
    
\subsection{\textbf{Prompt:}"Por que o processo de leitura das portas está demorando tanto?"}
    \textbf{Resposta}: Devico ao tempo de leitura em cada porta, settimeout(0.5) por porta causa lentidão. Sugestão de usar 0.1, com risco de falsos negativos.
\subsection{\textbf{Prompt:}\textit{ Erro sobre o nmap não encontrado} "Por que esse erro? Como resolver?"}
    \textbf{Resposta:} necessário instalar o Nmap no Windows e garantir que esteja no PATH.
\subsection{\textbf{Prompt:} "Como fazer para aceitar IPV6?"}
    \begin{lstlisting}
    import ipaddress
  import socket
  import nmap

  def scan_ports_with_socket(target):
      print("\n[+] Escaneando portas abertas com socket...")
      open_ports = []
      try:
          # Detecta automaticamente se o alvo e IPv4 ou IPv6
          family = socket.AF_INET6 if ':' in target else socket.AF_INET
          for port in range(22, 91):  # Escaneia as portas de 22 a 89
              try:
                  with socket.socket(family, socket.SOCK_STREAM) as s:
                      s.settimeout(0.5)  # Define um timeout para evitar travamentos
                      if s.connect_ex((target, port)) == 0:
                          open_ports.append(port)
                          print(f"[+] Porta {port} aberta")
              except Exception as e:
                  print(f"Erro ao escanear a porta {port}: {e}")
      except Exception as e:
          print(f"Erro ao configurar o socket: {e}")
      return open_ports

  def scan_services_with_nmap(target):
      print("\n[+] Identificando servicos ativos com nmap...")
      nm = nmap.PortScanner()
      try:
          # Adiciona o suporte a IPv6 com o argumento -6
          nm.scan(hosts=target, arguments='-sV --version-intensity 5 -p 22 -6')
          for host in nm.all_hosts():
              print(f"\nHost: {host} ({nm[host].hostname()})")
              print(f"Estado: {nm[host].state()}")
              for proto in nm[host].all_protocols():
                  print(f"\nProtocolo: {proto}")
                  ports = nm[host][proto].keys()
                  for port in ports:
                      service = nm[host][proto][port]
                      print(f"Porta: {port}\tEstado: {service['state']}\tServico: {service['name']}")
      except Exception as e:
          print(f"Erro ao usar nmap: {e}")

  def main():
      # Solicita ao usuario um endereco IP
      target = input("Digite o endereco IP para escanear: ")

      # Valida se o usuario forneceu uma entrada
      if not target.strip():
          print("Erro: Nenhum endereco IP foi fornecido.")
          return

      # Valida se o endereco fornecido e um IP valido
      try:
          ipaddress.ip_address(target)
          print(f"Alvo recebido: {target}")

          # Escaneia portas abertas com socket
          open_ports = scan_ports_with_socket(target)

          # Identifica servicos ativos com nmap
          if open_ports:
              scan_services_with_nmap(target)
          else:
              print("Nenhuma porta aberta encontrada para escanear servicos.")
      except ValueError:
          print("Erro: O endereco fornecido nao e um IP valido.")

  if _name_ == "_main_":
    main()
    \end{lstlisting}

    
\subsection{\textbf{Prompt:} "Por que o nmap não está identificando o serviço correto na porta?"}
    \begin{lstlisting}
    
  import ipaddress
  import socket
  import nmap

  def scan_ports_with_socket(target):
      print("\n[+] Escaneando portas abertas com socket...")
      open_ports = []
      try:
          # Detecta automaticamente se o alvo e IPv4 ou IPv6
          family = socket.AF_INET6 if ':' in target else socket.AF_INET
          for port in range(22, 91):  # Escaneia as portas de 22 a 89
              try:
                  with socket.socket(family, socket.SOCK_STREAM) as s:
                      s.settimeout(0.5)  # Define um timeout para evitar travamentos
                      if s.connect_ex((target, port)) == 0:
                          open_ports.append(port)
                          print(f"[+] Porta {port} aberta")
              except Exception as e:
                  print(f"Erro ao escanear a porta {port}: {e}")
      except Exception as e:
          print(f"Erro ao configurar o socket: {e}")
      return open_ports

  def scan_services_with_nmap(target):
      print("\n[+] Identificando servicos ativos com nmap...")
      nm = nmap.PortScanner()
      try:
          # Adiciona o suporte a IPv6 com o argumento -6
          nm.scan(hosts=target, arguments='-sV --version-intensity 5 -p 22 -6')
          for host in nm.all_hosts():
              print(f"\nHost: {host} ({nm[host].hostname()})")
              print(f"Estado: {nm[host].state()}")
              for proto in nm[host].all_protocols():
                  print(f"\nProtocolo: {proto}")
                  ports = nm[host][proto].keys()
                  for port in ports:
                      service = nm[host][proto][port]
                      print(f"Porta: {port}\tEstado: {service['state']}\tServico: {service['name']}")
      except Exception as e:
          print(f"Erro ao usar nmap: {e}")

  def main():
      # Solicita ao usuario um endereco IP
      target = input("Digite o endereco IP para escanear: ")

      # Valida se o usuario forneceu uma entrada
      if not target.strip():
          print("Erro: Nenhum endereco IP foi fornecido.")
          return

      # Valida se o endereco fornecido e um IP valido
      try:
          ipaddress.ip_address(target)
          print(f"Alvo recebido: {target}")

          # Escaneia portas abertas com socket
          open_ports = scan_ports_with_socket(target)

          # Identifica servicos ativos com nmap
          if open_ports:
              scan_services_with_nmap(target)
          else:
              print("Nenhuma porta aberta encontrada para escanear servicos.")
      except ValueError:
          print("Erro: O endereco fornecido nao e um IP valido.")

  if _name_ == "_main_":
    main()
    \end{lstlisting}

\subsection{\textbf{Prompt:} "Caso eu queira criar um arquivo .csv ou .json contendo os resultados da varredura o que eu teria que fazer?"}
    \begin{lstlisting}
        import json

def save_results_to_json(filename, results):
    try:
        with open(filename, mode='w', encoding='utf-8') as file:
            json.dump(results, file, indent=4)
        print(f"Resultados salvos em {filename}")
    except Exception as e:
        print(f"Erro ao salvar resultados no JSON: {e}")

    \end{lstlisting}
\subsection{\textbf{Prompt:} "O que é o json.dump e para que serve?"}
    O json.dump() é uma função da biblioteca json do Python que serve para salvar dados em formato JSON dentro de um arquivo.

\subsection{\textbf{Prompt:} \textit{Erro: No module nmap} "O que poderia ser esse erro?"}

\textbf{Resposta:} verificar instalação da lib python-nmap, usar pip show para checar, ou reinstalar.

\subsection{\textbf{Prompt:} "O resultado das portas abertas está dando a 22 e a 90, porém os resultados dos serviços ativos não batem com as portas."}

    \textbf{Resposta:}  Ele gerou sugestões, mas também causou problemas posteriores de leitura.

\subsection{\textbf{Prompt:}No caso de eu querer scanear as portas com o socket para passar a lista de portas abertas para scanear os serviços com o nmap, o que eu devo fazer?"}

    \textbf{Resposta:} Copilot sugeriu código que recebe portas abertas via socket e passa para o Nmap o que chegou no código final elaborado.


\section{Falhas no Código}

\subsection{Erro na Leitura de Serviços com Nmap}

O scanner apresentou falhas ao identificar serviços utilizando o \texttt{nmap}, resultando no seguinte erro:

\begin{lstlisting}
Nmap scan info: {'error': ['2804:360:40:2188:19ba:9b3:e4d5:fa89 looks like an IPv6 
target specification -- you have to use the -6 option.\r\nWARNING: No targets were 
specified, so 0 hosts scanned.\r\n'], 'warning': ['WARNING: No targets were specified, 
so 0 hosts scanned.\r\n'], 'tcp': {'method': 'syn', 'services': '22,90'}}
\end{lstlisting}

\textbf{Causa:} O script inicial não identificava corretamente se o alvo era um endereço IPv6, e o \texttt{nmap} exigia a flag \texttt{-6} para escanear corretamente.

\textbf{Solução:} Foi adicionada uma verificação que identifica se o alvo é IPv6 e adiciona automaticamente a flag \texttt{-6} ao comando \texttt{nmap}.

\begin{lstlisting}
is_ipv6 = ':' in target
arguments = f"-sV --version-intensity 9 -p {ports_to_scan}"
if is_ipv6:
    arguments += " -6"  # Adiciona a flag para IPv6

nm.scan(hosts=target, arguments=arguments)
\end{lstlisting}

\subsection{Tratamento de IPv6}

O script inicial não tratava adequadamente alvos IPv6, resultando em falha na execução do \texttt{nmap} e no escaneamento de portas com \texttt{socket}.

\textbf{Causa:} O \texttt{socket} por padrão usa \texttt{AF\_INET} (IPv4). Para suportar IPv6, era necessário modificar a família de endereço para \texttt{AF\_INET6} quando um endereço IPv6 fosse identificado.

\textbf{Solução:} O código foi ajustado para identificar automaticamente o tipo de IP e utilizar \texttt{AF\_INET6} para IPv6.

\begin{lstlisting}
family = socket.AF_INET6 if ':' in target else socket.AF_INET

with socket.socket(family, socket.SOCK_STREAM) as s:
    s.settimeout(0.5)
    if s.connect_ex((target, port)) == 0:
        open_ports.append(port)
\end{lstlisting}

\subsection{Falha no Salvamento de Resultados}

Inicialmente, o scanner não salvava os resultados do escaneamento rápido, apenas os do escaneamento detalhado.

\textbf{Causa:} O salvamento estava implementado apenas na função de escaneamento detalhado.

\textbf{Solução:} Foi adicionada a função \texttt{save\_results\_to\_json()} também ao escaneamento rápido, armazenando as portas abertas em um arquivo JSON.

\begin{lstlisting}
def quick_scan():
    open_ports = scan_ports_with_socket(target)
    if open_ports:
        results = [{"port": port, "state": "open"} for port in open_ports]
        save_results_to_json("scan_results.json", results)
\end{lstlisting}

\subsection{Validação de Entrada do Usuário}

Se o usuário fornecesse um IP inválido, o programa poderia travar ou retornar erros inesperados.

\textbf{Causa:} O script original não validava corretamente se o IP fornecido era válido antes de tentar escaneá-lo.

\textbf{Solução:} Foi adicionada uma função \texttt{validate\_ip()} para verificar a validade do endereço antes de iniciar o escaneamento.

\begin{lstlisting}
def validate_ip(target):
    try:
        ipaddress.ip_address(target)
        return True
    except ValueError:
        print("Erro: O endereco fornecido nao e um IP valido.")
        return False

target = input("Digite o endereco IP: ").strip()
if not validate_ip(target):
    exit()
\end{lstlisting}

\subsection{Melhorias no Menu Interativo}

Um menu interativo foi solicitado para permitir que o usuário escolha entre um escaneamento rápido e um escaneamento detalhado.

\textbf{Solução:} O menu foi implementado com as opções "Escaneamento rápido" e "Escaneamento detalhado". O escaneamento rápido detecta portas abertas, enquanto o detalhado também identifica serviços ativos nas portas encontradas.

\begin{lstlisting}
def main():
    while True:
        print("\n=== Menu de Escaneamento ===")
        print("1. Escaneamento rapido")
        print("2. Escaneamento detalhado")
        print("3. Sair")

        choice = input("Escolha uma opcao: ").strip()
      
        if choice == "1":
            quick_scan()
        elif choice == "2":
            detailed_scan()
        elif choice == "3":
            print("\n[+] Saindo do programa. Ate logo!")
            break
        else:
            print("\n[!] Opcao invalida. Tente novamente.")
\end{lstlisting}

\section{Problemas de Segurança}

\subsection{Uso do \texttt{nmap} sem Filtragem Adequada}

O código abaixo não valida nem sanitiza a entrada antes de construir o comando \texttt{nmap}. Isso pode ser explorado por um atacante para injetar parâmetros maliciosos.

\begin{lstlisting}
arguments = f'-sV --version-intensity 9 -p {ports_to_scan}'
if is_ipv6:
    arguments += ' -6'  # Add the IPv6 flag if the target is IPv6
print(f"Comando Nmap: {arguments}")
nm.scan(hosts=target, arguments=arguments)
\end{lstlisting}

\subsection{Exposição de Resultados Sensíveis}

O código imprime informações sensíveis sobre os hosts e serviços escaneados diretamente no console, o que pode expor dados críticos caso o sistema seja acessado por terceiros.

\begin{lstlisting}
print(f"Nmap scan info: {nm.scaninfo()}")
print(f"Nmap all hosts: {nm.all_hosts()}")
\end{lstlisting}

\subsection{Falta de Rate Limiting}

O código escaneia portas rapidamente, sem implementar uma pausa entre as requisições. Isso pode ser interpretado como um ataque de varredura (brute force) e pode fazer com que o sistema seja bloqueado ou marcado como um atacante.

\begin{lstlisting}
for port in range(22, 91):  # Escaneia as portas de 22 a 89
    try:
        with socket.socket(family, socket.SOCK_STREAM) as s:
            s.settimeout(0.5)  # Define um timeout para evitar travamentos
            if s.connect_ex((target, port)) == 0:
                open_ports.append(port)
                print(f"[+] Porta {port} aberta")
    except Exception as e:
        print(f"Erro ao escanear a porta {port}: {e}")
\end{lstlisting}

\subsection{Falta de Registro de Erros}

Embora o código capture erros, ele simplesmente imprime as falhas na tela, sem um sistema de registro de logs adequado. Isso dificulta a depuração e o monitoramento do sistema em produção.

\begin{lstlisting}
print(f"Erro ao usar nmap: {e}")
print(f"Erro ao salvar resultados no JSON: {e}")
\end{lstlisting}


\section{Análise dos Resultados}

\subsection{Comportamento do Desenvolvedor Durante o Uso da IA}

Ao avaliar os prompts, é possível observar que o desenvolvedor inicialmente demonstrava interesse em compreender o funcionamento do código gerado pela IA, sendo evidenciado por perguntas como "O que significa e para que serve o .strip()?" e "O que seria a biblioteca Socket?", indicando uma tentativa inicial de aprendizado e entendimento das ferramentas e conceitos apresentados.

No entanto, à medida que o projeto avançava e se tornava mais complexo, o comportamento do desenvolvedor mudou, ele passou a confiar mais na IA para tomar decisões e resolver problemas, muitas vezes aceitando o código gerado sem questionar ou compreender completamente seu funcionamento. Isso é especialmente evidente em momentos em que o desenvolvedor enfrentava dificuldades, como na integração do suporte a IPv6 ou na identificação de serviços ativos com o \texttt{nmap}. Nessas situações, o desenvolvedor recorria à IA para obter soluções prontas, sem buscar entender os detalhes técnicos ou as implicações do código gerado.

Essa mudança de comportamento, mesmo que em uma pequena escala, reflete uma dependência crescente da ferramenta, o que pode ser problemático em projetos mais avançados, pois a falta de compreensão do código gerado pode levar a erros ocultos, dificuldades na manutenção e riscos de segurança. Além disso, a confiança excessiva na IA pode limitar o desenvolvimento das habilidades técnicas do desenvolvedor, criando um ciclo de dependência que dificulta a resolução de problemas de forma autônoma.

\subsection{Vantagens da Utilização da IA no Desenvolvimento de Software}

\begin{itemize}
    \item \textbf{Aceleração do Desenvolvimento}: Ferramentas de IA podem gerar código rapidamente, economizando tempo dos desenvolvedores.
    \item \textbf{Redução de Erros Comuns}: Muitos erros sintáticos e padrões de código ruins podem ser evitados com sugestões baseadas em IA.
    \item \textbf{Auxílio na Aprendizagem}: Desenvolvedores iniciantes podem usar IA para compreender padrões e boas práticas de programação.
    \item \textbf{Automação de Tarefas Repetitivas}: Testes automatizados, geração de documentação e refatoração de código podem ser otimizados.
    \item \textbf{Melhoria na Manutenção do Código}: Ferramentas de IA podem sugerir melhorias para aumentar a eficiência e a legibilidade do código.
\end{itemize}

\subsection{Desvantagens da Dependência Excessiva}

\begin{itemize}
    \item \textbf{Código sem Compreensão}: Desenvolvedores podem adotar código gerado sem entender seu funcionamento, levando a falhas ocultas.
    \item \textbf{Falsa Segurança}: Acreditar que a IA sempre gera código correto pode resultar em vulnerabilidades de segurança e falhas de execução.
    \item \textbf{Repetição de Padrões Ruins}: Se a IA for treinada em código de baixa qualidade, ela pode perpetuar más práticas e padrões inseguros.
    \item \textbf{Problemas de Generalização}: A IA pode não entender contextos específicos, gerando soluções inadequadas ou ineficazes.
    \item \textbf{Dependência Exagerada}: Equipes podem perder habilidades essenciais, confiando exclusivamente na IA para decisões técnicas.
\end{itemize}

\section{Conclusão}

A Inteligência Artificial é, sem dúvida alguma, uma ferramenta poderosa que está transformando o desenvolvimento de software e sua capacidade de gerar código rapidamente, automatizar tarefas repetitivas e apoiar em soluções para problemas complexos pode agilizar significativamente o trabalho dos desenvolvedores. No entanto, o uso inconsequente e inconsciente dessa tecnologia pode criar uma divisão clara entre bons programadores e programadores dependentes.

Bons programadores, que possuem conhecimento técnico sólido e a capacidade de avaliar criticamente o código gerado pela IA, conseguem aproveitar ao máximo os benefícios dessa ferramenta, eles utilizam a IA como um suporte para aumentar sua produtividade, mantendo o controle sobre as decisões técnicas e garantindo a qualidade e a segurança do código, por outro lado, programadores que dependem exclusivamente da IA, sem compreender o que está sendo gerado, correm o risco de produzir sistemas frágeis, com falhas ocultas e vulnerabilidades de segurança.

Essa diferença será um fator determinante no mercado de trabalho e empresas não precisarão mais de programadores fracos para realizar atividades simples, pois um único bom programador, com a IA ao seu lado, pode realizar o trabalho de vários desses profissionais em um tempo muito menor, o que resultará em economia de tempo e dinheiro para as empresas, tornando o domínio técnico e a capacidade de usar a IA de forma consciente um diferencial competitivo essencial.

Portanto, o futuro do desenvolvimento de software não está apenas no uso da IA, mas na combinação de conhecimento técnico, pensamento crítico e habilidade para avaliar e validar o que a ferramenta gera. Programadores que dominarem essa combinação estarão melhor posicionados para se destacar em um mercado cada vez mais exigente e competitivo.

\end{document}